# -*- coding: utf-8 -*-
"""A20549858_INTRO-TO-INFOSEC_mansipatil_ass1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bsc075KpVNqA4S5ohxxbk1igVfY2wYYe
"""

                                              #MANSI PATIL (A20549858)
                                                #CODING ASSIGNMENT1


#The basic terminology includes the following:
#Plaintext: original message given by the user
#Ciphertext: encrypted or coded message
#Encryption: convert from plaintext to ciphertext (enciphering)
#Decryption: restore the plaintext from ciphertext (deciphering)
#Key: Secret information used in cipher known only to sender/receiver

def encryption(ptext, secret_ky):
   #Encryption means converting plaintext into ciphertext using secret key provided by the user.
   #plaintext(ptext): The text to be encrypted (string).
   #encriphering is done by Shifting each letter by key positions for example if letter(plaintext)is given as A and key is given as 3 so it will shift letters by 3 means ciphertext will be d.

  if not ptext:
    raise ValueError("Plaintext cannot be empty.")                         #Check if plaintext is empty or not.

  if not all(c.isalpha() or c.isspace() for c in ptext):
      raise ValueError("Plaintext must contain only letters")             #Check if plaintext contains only letters
  try:
    secret_ky = int(secret_ky)
  except ValueError:
    raise ValueError("Key must be a valid integer.")                       #Throw an error if key is non numeric value.

  ctext = ""
  for character in ptext:
    if character.isalpha():


      ascii = ord('A') if character.isupper() else ord('a')               #ASCII value for uppercase or lowercase letters

      # Calculate the new ASCII code
      new_char = (ord(character) - ascii + secret_ky) % 26 + ascii       # Encryption can be described mathematically as En(x)=(x+n) mod {26}.
      ctext += chr(new_char)
    else:
      ctext = ctext + character
  return ctext


def decryption(ctext, secret_ky):
  #decryption means converting the ciphertext into plaintext using secret key provided by the user.
  #Decrypts the ciphertext using a Caesar cipher with the given key.
  #Deciphering is done in reverse, with a left shift of key (given by the user), for example if letter(ciphertext) is given as D and key is given as 3 then it will give plaintext as A.
  #cipher(ctext): The text to be decrypted (string).

  if not ctext:
    raise ValueError("Ciphertext cannot be empty.")                          # Check if ciphertext is empty

  if not all(c.isalpha() or c.isspace() for c in ctext):
    raise ValueError("Ciphertext must contain only letters.")               # Check if ciphertext contains only letters
  try:
    secret_ky = int(secret_ky)
  except ValueError:
    raise ValueError("Key must be a valid integer.")

  ptext = ""
  for character in ctext:
    if character.isalpha():
                                                                     #  ASCII value for uppercase or lowercase letters
      ascii = ord('A') if character.isupper() else ord('a')
                                                                        # Calculate new ASCII code
      new_char = (ord(character) - ascii - secret_ky + 26) % 26 + ascii
      # Append the decrypted character to the plaintext
      ptext += chr(new_char)
    else:
       # If the character is not a letter, append it unchanged
      ptext = ptext + character
  return ptext

def brute_force_attack(ctext):
  #brute force attack to try all possible keys (shift values) for Caesar cipher.
  #decrypt the ciphertext using all possible keys.
  #ciphertext(ctext): The text to be decrypted (string).
  #brute force attack will Display all the possible plaintext results.


  if not ctext:
    raise ValueError("Ciphertext cannot be empty.")                         # Check if ciphertext is empty or not

  if not all(c.isalpha() or c.isspace() for c in ctext):
    raise ValueError("Ciphertext must contain only letters.")              # Check if ciphertext contains only letters or not


  # Try all possible keys (0-25) and print all plaintexts.
  for secret_ky in range(26):

    ptext = decryption(ctext, secret_ky)                                   # Decrypt ciphertext using the key.

    print(f"Key {secret_ky}: {ptext}")                                    # Print decrypted plaintext with the key.

def Encrypt_Decrypt_Brute():
  while True:
    print("\nChoose an option::")
    print("1. Encryption")
    print("2. Decryption")
    print("3. Brute Force Attack")
    your_choice = input("Enter your choice (1/2/3): ")

    if your_choice == "1":
      ptext = input("\nEnter plaintext: ")
      try:
        secret_ky = int(input("Enter key: "))
      except ValueError:
        print("Error: Key must be a valid integer.")
        continue
      try:
        ctext = encryption(ptext, secret_ky)
        print("Ciphertext:", ctext)
      except ValueError as e:
        print("Error:", e)
    elif your_choice == "2":
      ctext = input("\nEnter ciphertext: ")
      try:
        secret_ky = int(input("Enter key: "))
      except ValueError:
        print("Error: Key must be a valid integer.")
        continue
      try:
        ptext = decryption(ctext, secret_ky)
        print("Plaintext:", ptext)
      except ValueError as e:
        print("Error:", e)
    elif your_choice == "3":
      ctext = input("\nEnter ciphertext: ")
      # Check if ciphertext is empty or contains non-letters.
      if not ctext:
        print("Error: Ciphertext cannot be empty.")
        continue
      elif not all(c.isalpha() or c.isspace() for c in ctext):
        print("Error: Ciphertext must contain only letters.")
        continue
         # Perform brute force attack on ciphertext.
      brute_force_attack(ctext)
    else:
      print("Invalid choice.")

if __name__ == "__main__":
  Encrypt_Decrypt_Brute()